\documentclass{article}

\begin{document}
\section{Disorder is a friend of scaling}

\subsection{Streaming through RAM}
\begin{itemize}
\item Instead of reading and writing a single item at a time, batch things up
\item When input buffer consumed, read another chunk. When out buffer fills, write to output using f(x) in the middle
\item We can simply partition the input and parallelize
\end{itemize}

\subsection{Rendezvous}
\begin{itemize}
\item Streaming one chunk at a time is easy, but some algorithms need certain items to be co-resident in memory (not guaranteed to appear in the same input chunk)
\item \textbf{Time-space rendezvous}: in the same place (RAM) at the same time - most of computing is about this
\item Divide and Conquer: you have B chunks, use 1 for read into and one for write into, leaving B-2 chinks of RAM left as space for rendezvous
\end{itemize}

\section{SQL}
The standard for database queries - has been around since the 70s and remains the top language
\subsection{Pros and Cons}
\textbf{Pros}: SQL is a declarative language and is widely implemented (varying levels of efficiency and completeness). It is also general-purpose and feature-rich (many years of added features, extensible: callouts to other languages, data sources) \\ 
\textbf{Cons}: Constained (Core SQL is not a Turing-complete language - extensions make it Turing complete) 

\subsection{Relation Terminology}
\begin{itemize}
\item Database: set of relations
\item Relation (Table): Schema (description, schema of database is set of schema of its relations), Instance (data satisfying the schema)
\item Attribute (Column)
\item Tuple (Record, Row)
\item Schema is fixed, set up in the beginning. Attribute names, atomic types. Populated with data that changes over time
\item Instance can change: a multi-set of rows. Tables are unordered and there can be repeats
\item DDL: Data Definition Langue is where you declare hat you want your tables to be and look like.
\item DML: Data Manipulation language is where you say what info you actually want in the table
\item RDBMS is responsible for efficient evaluation
\end{itemize}
Foreign Key (sid) References Sailors: this means that the sid will be tied to the sid in the Sailors table - you can't put something in the new table that didn't exist in the other table

\subsection{Single Relation Queries}
DISTINCT means remove duplicates
SELECT [DISTINCT] what you want \\
FROM table  \\
WHERE condition \\
GROUP BY column list\\ 
HAVING predicate \\
ORDER BY  column list\\
\\
Aggregates compute a summary of some arithmetic expression and produce one row of output \\
Group by partitions the table into seperate areas and produce aggregate result per group - cardinality of output is the number of distinct group values \\ 
Having predicate is applied after grouping and aggregation - hence can contain anything that could go in the SELECT list - only used in aggregate queries \\ \\ 
\textbf{Order}: FROM comes first - gives us the table. Then we look at the table data and stream it through the WHERE clause. In the SELECT clause we see which columns we actually care about. Then we do GROUP BY and create buckets and collect tuples for each bucket. Then we look at the HAVING clause and throw out any bucket that doesn't satisfy. Then we eliminate duplicates if DISTINCT is on and then we do that AGGREGATE 

\subsection{Querying Multiple Relations - Join Queries}
FROM Sailors S, Reserves R - we have multiple tables in this clause \\ 
WHERE S.sid = R.sid - otherwise we get nonsense \\ \\
Range Variabels: needed when ambiguity could arise - same table used multiple times in FROM \\ 
Where S.name LIKE 'P(underscor)p(percent sign)' means name starts with a P then some stuff then a lower case p \\ 
EXCEPT can remove sailors who have reserved a boat - removing some group - also eliminates duplicates

\subsection{Nested Queries}
WHERE S.sid IN \\ 
For each S.sid check if it is in the nested table (can also do NOT IN) \\  \\
WHERE EXISTS (subtable) - subtable will include WHERE S.sid = R.sid \\ \\ 
WHERE S.rating > ANY - where the rating is bigger than some selected rating value in the subtable

\subsection{NULL Values}
Field values that are sometimes unknown or inapplicable - SQL provides a special value null for such situations \\ 
In a truth table - ? or True = True, ? and True = ?, etc. - these are unknown values

\subsection{Inner Join and Outer Join}
FROM Sailors S \\ INNER JOIN Reserves r \\ ON s.sid = r.sid \\
ON is called the join condition \\ \\
FROM Sailors S \\ LEFT OUTER JOIN Reserves r \\ ON s.sid = r.sid \\
We return all the matching rows, plus all unmatched rows from the table on the left of the join clause - use nulls in fields of non-matching tuples \\
Full Outer Join will use nulls to fill in blanks from both tables

\subsection{Views: Named Queries}
CREATE VIEW viewName \\ AS selectStatement \\ 
Views make development simpler, used for security, not "materialized" (you just store the select statement - you don't store the actual table) \\  \\
GRANT privileges ON object TO users \\ 
Object can be a Table or a view, Privileges talk about operations allowed on those table - Select, insert, delete, reference (create foreign key that references specified columns), all - can later be revoked

\subsection{Subqeiers in FROM}
Akin to a view \\ 
FROM Boads2 b, \\
(SELECT b.bid, COUNT(*) \\
FROM ... WHERE ...) AS Reds(Bid, scount) \\ 
Now you can refer to Reds later - this is a view created on the fly

\subsection{Constrains}
\textbf{Integrity Constrains}: conditions that every legal instance of a relation must satisfy (similar to assertions in other languages) \\
Inserts/deletes/updates that violate IC's are disallowed - can ensure application semantics (sid is a key) or prevent inconsistensies (sname must be a string) \\ \\
\textbf{Domain Constrians}: field values must be of the right type (always enforced) \\ \\
\textbf{Primary Key and Foreign Key Constraints}: keys are way to associate tuples in different relations - one form of ICn. A foreign key is when a key references a table where it isn't the primary key (sid primary key in students table but foreign key in classes table) \\ 
FOREIGN KEY (sid) REFERENCES Students - can use to prevent not inserting a student ID that doesn't actually correspond to a student \\
Cascading delete means that the delete propagates to the tables which refer to the original table \\
\textbf{Superkey}: no two distinct tuples can have the same value in all key fields \\
\textbf{General Constaint}: Check (rating between one AND ten) - they can be more complicated and actually be select from where queries

\section{Disks and Files}
\subsection{Database Management System (DBMS) Architecture}
First you do query parsing and check validity. Then optimization turns this query into something that can actually be handled by the system. This takes us to a relational operators which access something lower down - the files and index management. The layer belwo this is the buffer management which plays the role of essentially virtual memory. Below this level is the disk/flash drive - each layer abstracts the layer below, allowing us to manage complexity and make performance instructions
\subsection{Disk Space and Buffer Management}
Going back and forth between disk and ram: program operates on data that is actually in memory - there is some interface with the disk that puts this world together and this is the buffer pool or buffer manager - manages a relatively small amount of pages of memory that deal directly with disk. \\  \\ 
How are tables stored on disk? - usually stored as a logical file of some sort that can be broken up into pages, where each page contains a collection of records. \\ 
\textbf{Pages} are managed in memory, by the buffer manager - higher levels of database only operate in memory and on disk by the disk space manager which reads and writes pages to physical disk/files
\subsection{Storage Media}
A lot of databases still use magnetic disks - a mechanical anachronism - API exists to actually deal with physical memory when you read and write - these API calls are expensive \\
Economics: RAM is much more expensive than Magnetic disk, which is also more expensive than solid state disk \\ 
Storage Hierarchy: Registers, on-chip cache (very fast, small), on-board cache (slower, larger), RAM (currently used data), SSD (varies by deployment - sometimes database/cache) , Disk (database and backups/logs)
\subsection{Components of a Disk}
Platters spin (maybe 15000 rpm) - Arm assembly moved in or out to position a head on a desired track - each platter made up of tracks which are concentric rings \\ 
Only one head reads/writes at a time - block/page size is a multiple of fixed sector size \\ \\ 
Key to lower cost is reducing seek and rotational delays \\ 
\textbf{Seek time}: how long it takes to ove the arm to position disk head on track \\ 
\textbf{Rotational delay}: how long it takes for the block to rotate under head \\ 
\textbf{Transfer time}: actually moving data to/from disk surface \\ 
\subsection{Flash (SSD)}
The cost of flash has come down dramatically recently - the current generation of flash devices have differences between reads and writes (small reads, big writes) - flash also gets worn out over time - tries to wear level and spread things out so one area isn't overused \\ 
Write amplication: big units, so to even write something small you still have to write a lot \\ 
Random reads are fast and predictable with no seek penalty - sequential reads also perform similarly (unlike hard drive). But writes are slower for random than sequential writes.
\subsection{Storage Pragmatics and Trends}
Many significant DBs are not that big - but data sizes grow faster than Moore's Law - minimize seek and rotational delay because we are faced with hard disks. The role of flash and RAM has increased recently














\end{document}
